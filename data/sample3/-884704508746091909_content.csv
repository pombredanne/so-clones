"Content"
"    // may tried RandomAccess/SequentialScan&#xD;&#xA;    MemoryMapped MemFile(FilterBase.BaseFileName, MemoryMapped::WholeFile, MemoryMapped::RandomAccess);&#xD;&#xA;    // point to start of memory file&#xD;&#xA;    char* start = (char*)MemFile.getData();&#xD;&#xA;    // dummy in my case&#xD;&#xA;    char* tmpBuffer = start;&#xD;&#xA;    // looping counter&#xD;&#xA;    uint64_t i = 0;&#xD;&#xA;    // pre-allocate result vector&#xD;&#xA;    MyVector.resize(300000);&#xD;&#xA;    // Line counter&#xD;&#xA;    int LnCnt = 0;&#xD;&#xA;    //no. of field&#xD;&#xA;    int NumOfField=43;&#xD;&#xA;    //delimiter count, num of field + 1 since the leading and trailing delimiter are virtual&#xD;&#xA;    int DelimCnt=NoOfField+1;&#xD;&#xA;    //Delimiter position. May use new to allocate at run time&#xD;&#xA;    // or even use vector of integer&#xD;&#xA;    // This is to store the delimiter position in each line&#xD;&#xA;    // since the position is relative to start of file. if file is extremely&#xD;&#xA;    // large, may need to change from int to unsigner, long or even unsigned long long&#xD;&#xA;    static  int DelimPos[DelimCnt];&#xD;&#xA;    // Max number of field need to read usually equal to NumOfField, can be smaller, eg in my case, I only need 4 fields&#xD;&#xA;    // from first 15 field, in this case, can assign 15 to MaxFieldNeed&#xD;&#xA;    int MaxFieldNeed=NumOfField;&#xD;&#xA;    // keep track how many comma read each line&#xD;&#xA;    int DelimCounter=0;&#xD;&#xA;    // define field and line seperator&#xD;&#xA;    char FieldDelim=',';&#xD;&#xA;    char LineSep='\n';&#xD;&#xA;    // 1st field, """"""""virtual Delimiter"""""""" position&#xD;&#xA;    DelimPos[CommaCounter]=-1&#xD;&#xA;    DelimCounter++;&#xD;&#xA;    // loop through the whole memory field, 1 and only once&#xD;&#xA;    for (i = 0; i < MemFile.size();i++)&#xD;&#xA;    {&#xD;&#xA;      // grab all position of delimiter in each line&#xD;&#xA;      if ((MemFile[i] == FieldDelim) && (DelimCounter<=MaxFieldNeed)){&#xD;&#xA;        DelimPos[DelimCounter] = i;&#xD;&#xA;        DelimCounter++;&#xD;&#xA;      };&#xD;&#xA;      // grab all values when end of line hit&#xD;&#xA;      if (MemFile[i] == LineSep) {&#xD;&#xA;        // no need to use if (DelimCounter==NumOfField) just assign anyway, waste a little bit&#xD;&#xA;        // memory in integer array but gain performance &#xD;&#xA;        DelimPos[DelimCounter] = i;&#xD;&#xA;        // I know exactly what the format is and what field(s) I want&#xD;&#xA;        // a more general approach (as a CSV reader) may put all fields&#xD;&#xA;        // into vector of vector of string&#xD;&#xA;        // With *EFFORT* one may modify this piece of code so that it can parse&#xD;&#xA;        // different format at run time eg similar to:&#xD;&#xA;        // fscanf(fstream,""""""""%d,%f....&#xD;&#xA;        // also, this piece of code cannot handle complex CSV e.g.&#xD;&#xA;        // Peter,28,157CM&#xD;&#xA;        // John,26,167CM&#xD;&#xA;        // """"""""Mary,Brown"""""""",25,150CM&#xD;&#xA;        MyVector.StrField = string(strat+DelimPos[0] + 1, strat+DelimPos[1] - 1);&#xD;&#xA;        MyVector.IntField = strtol(strat+DelimPos[3] + 1,&tmpBuffer,10);&#xD;&#xA;        MyVector.IntField2 = strtol(strat+DelimPos[8] + 1,&tmpBuffer,10);&#xD;&#xA;        MyVector.FloatField = strtof(start + DelimPos[14] + 1,&tmpBuffer);&#xD;&#xA;        // reset Delim counter each line&#xD;&#xA;        DelimCounter=0&#xD;&#xA;        // previous line seperator treat as first delimiter of next line&#xD;&#xA;        DelimPos[DelimCounter] = i;&#xD;&#xA;        DelimCounter++&#xD;&#xA;        LnCnt++;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    MyVector.resize(LnCnt);&#xD;&#xA;    MyVector.shrink_to_fit();&#xD;&#xA;    MemFile.close();&#xD;&#xA;    };"
