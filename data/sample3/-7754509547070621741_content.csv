"Content"
"    #ifndef QUEUETEMPLATE_H&#xD;&#xA;    #define QUEUETEMPLATE_H&#xD;&#xA;    #include """"""""queue.h""""""""&#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    // Constructor&#xD;&#xA;    template <class Type>&#xD;&#xA;    queue<Type> :: queue(int queuesize): &#xD;&#xA;    	Front(0), Back(0),&#xD;&#xA;    	QueueSize(queuesize),&#xD;&#xA;    	Contents(new Type[queuesize + 1])&#xD;&#xA;    {}&#xD;&#xA;    &#xD;&#xA;    // Destructor&#xD;&#xA;    template <class Type>&#xD;&#xA;    queue<Type> :: ~queue()&#xD;&#xA;    {&#xD;&#xA;    	delete[] Contents;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Tests&#xD;&#xA;    template <class Type>&#xD;&#xA;    bool queue<Type> :: Empty() const&#xD;&#xA;    {&#xD;&#xA;    	return (Front == Back) ? true : false;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    template <class Type>&#xD;&#xA;    bool queue<Type> :: Full() const&#xD;&#xA;    {&#xD;&#xA;    	return ((1 + Back) % (QueueSize + 1) == Front) ? true : false;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Push and pop&#xD;&#xA;    template <class Type>&#xD;&#xA;    bool queue<Type> :: Remove(Type& FrontElement)&#xD;&#xA;    {&#xD;&#xA;    	if (Empty())&#xD;&#xA;    	{&#xD;&#xA;    		return false;&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		FrontElement = Contents[Front];&#xD;&#xA;    		Front = (Front + 1) % (QueueSize + 1);&#xD;&#xA;    		return true;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    template <class Type>&#xD;&#xA;    bool queue<Type> :: Add(Type& NewElement)&#xD;&#xA;    {&#xD;&#xA;    	if(Full())&#xD;&#xA;    	{&#xD;&#xA;    		return false;&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		Contents[Back] = NewElement;&#xD;&#xA;    		Back = (Back + 1) % (QueueSize + 1);&#xD;&#xA;    		return true;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    #endif"
